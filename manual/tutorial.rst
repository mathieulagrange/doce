Tutorial
^^^^^^^^

This section covers the fundamentals of developing with *doce*, including
a package overview, basic and advanced usage.  We will assume basic familiarity with Python and NumPy.


Overview
~~~~~~~~

The *doce* package is structured as collection of submodules that are each responsible for the important parts of managing a computational experiment:

  - :ref:`doce.cli <cli>`
      Command-line interaction.
  - :ref:`doce.experiment <experiment>`
      Specify every aspects of the experiments from naming, storage location, plan, etc...
  - :ref:`doce.plan <plan>`
      Generate a number of settings by selecting factors and modalities of a given plan.
  - :ref:`doce.setting <setting>`
      Manipulate the settings generated by the plan.
  - :ref:`doce.metric <metric>`
      Manipulate and retrieve the output data.
  - :ref:`doce.util <util>`
      Utility functions.

.. _quickstart:

Quickstart
~~~~~~~~~~

The *doce* package is designed to require very few lines of code around your processing code to handle the task of evaluating its performance with respect to different parametrizations.

Define the experiment
=====================

In a .py file, ideally named after the name of your experiment (demo.py here, available in the examples directory), you have to implement a *set* function that contains the relevant definition of your experiment.

.. code-block:: python
    :linenos:

    # define the doce environnment
    def set(args):
      # define the experiment
      experiment = doce.Experiment(
        name = 'demo',
        purpose = 'hello world of the doce package',
        author = 'mathieu Lagrange',
        address = 'mathieu.lagrange@ls2n.fr',
      )
      # set acces paths (here only storage is needed)
      experiment.setPath('output', '/tmp/'+experiment.name+'/')
      # set some non varying parameters (here the number of cross validation folds)
      experiment.n_cross_validation_folds = 10

Define the plan
===============

In *doce*, the parametrization of the processing code is called a *setting*. Each setting is a set of *factors*, each factor being uniquely instantiated by a *modality*, chosen among a pre-defined set of modalities.

.. code-block:: python
    :linenos:

    # set the plan (factor : modalities)
    experiment.addPlan('plan',
      nn_type = ['cnn', 'lstm'],
      n_layers = np.arange(2, 10, 3),
      learning_rate = [0.001, 0.0001],
      dropout = [0, 1]
    )

Interact with your experiment
=============================

The *doce* package have a convenient way of interacting with experiments, through the command-line. For this to work, you need to add those lines to your python file:

.. code-block:: python
    :linenos:

    # invoke the command line management of the doce package
    if __name__ == "__main__":
      doce.cli.main()

Now you can interact with your experiment. For example you can display the plan:

.. code-block:: console

  $ python demo.py -p
           Factors      0       1  2
  0        nn_type    cnn    lstm
  1       n_layers      2       5  8
  2  learning_rate  0.001  0.0001  0.00001
  3        dropout      0       1

You can also access to a reference list of each pre-defined argument:

.. code-block:: console

  $ python demo.py -h
  usage: demo.py [-h] [-A [ARCHIVE]] [-C] [-d [DISPLAY]] [-E [EXPORT]] [-H HOST] [-i] [-K [KEEP]] [-l]
                 [-M [MAIL]] [-p] [-P [PROGRESS]] [-r [RUN]] [-R [REMOVE]] [-s SELECT] [-S] [-u USERDATA]
                 [-v] [-V]

  optional arguments:
    -h, --help            show this help message and exit
  ...

Control the plan
================

You can list the different settings generated by the plan:

.. code-block:: console

  $ python demo.py -l
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=1
  nn_type=cnn+n_layers=2+learning_rate=0dot0001+dropout=0
  ... (36 lines)

Most of the time you want to process or retrieve the output data of a *selection* of settings. Doce provides 3 selection formats for expressing that selection :
 1. the string format,
 2. the dictionary format,
 3. the numeric array format.

Suppose you want to select the settings with n_layers=2 and no dropout, you can do that easily with a string formatted selector:

.. code-block:: console

  python demo.py -l -s n_layers=2+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot0001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=0
  nn_type=lstm+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=lstm+n_layers=2+learning_rate=0dot0001+dropout=0
  nn_type=lstm+n_layers=2+learning_rate=1edash05+dropout=0

Suppose you want to select the settings with nn_type=cnn, n_layers=2, n_layers=8 and no dropout with the string format, the only way is to chain selectors:

.. code-block:: console

  $ python demo.py -l -s nn_type=cnn+n_layers=2+dropout=0,nn_type=cnn+n_layers=5+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot0001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=0dot0001+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=1edash05+dropout=0

This can get tedious when you want to select multiple modalities for multiple factors. For example, suppose you want to select the settings with nn_type=cnn, n_layers=[2, 4] and learning_rate= [0.001, 0.00001], you can do that conveniently with a dictionary formatted selector:

.. code-block:: console

  $ python demo.py -l -s '{"nn_type"="cnn", "n_layers":[2, 5],"learning_rate":[0.001,0.00001]}'
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=1
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=1
  nn_type=cnn+n_layers=5+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=0dot001+dropout=1
  nn_type=cnn+n_layers=5+learning_rate=1edash05+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=1edash05+dropout=1

The '' delimiters are required to avoid interpretetation of the selector by the shell. The " inside the selector delimiters *must not* be replaced by '' delimiters.

You can perform the same selection with a numeric array formatted selector:

.. code-block:: console

  $ python demo.py -l -s '[0,[0, 1],[0, 2]]'
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=0dot001+dropout=1
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=0
  nn_type=cnn+n_layers=2+learning_rate=1edash05+dropout=1
  nn_type=cnn+n_layers=5+learning_rate=0dot001+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=0dot001+dropout=1
  nn_type=cnn+n_layers=5+learning_rate=1edash05+dropout=0
  nn_type=cnn+n_layers=5+learning_rate=1edash05+dropout=1

As with the string selector, the dict and numeric array types of selector can be chained with a ,.

Define processing code
======================

You must define which code shall be processed for any setting, given the computing environnent defined by the experiment by implementing a step function:

.. code-block:: python
    :linenos:

    # the accuracy  is a function of cnn_type, and use of dropout
    accuracy = (len(setting.nn_type)+setting.dropout+np.random.random_sample(experiment.n_cross_validation_folds))/6
    # duration is a function of cnn_type, and n_layers
    duration = len(setting.nn_type)+setting.n_layers+np.random.randn(experiment.n_cross_validation_folds)
    # storage of outputs (the string between _ and .npy must be the name of the metric defined in the set function)
    np.save(experiment.path.output+setting.id()+'_accuracy.npy', accuracy)
    np.save(experiment.path.output+setting.id()+'_duration.npy', duration)

In this demo, the processing code simply stores some dummy metrics to the disk.

Perform computation
===================

Now that we have set all this, performing the computation of some settings can simply be done by:

.. code-block:: console

  $ python demo.py -r -s '{"nn_type"="cnn", "n_layers":[2, 5],"learning_rate":[0.001,0.00001]}'

Adding a -P to the command line conveniently displays a per setting progress bar.

Define metrics
==============

Before inspecting the results of our computation, we have to define how the metrics stored on disc shall be reduced and interpreted.

To do so, we have to add some lines to the set function:
.. code-block:: python
    :linenos:

    # set the metrics
    experiment.setMetrics(
      # the average and the standard deviation of the accuracy are expressed in percents (+ specifies a higher-the-better metric)
      accuracy = ['mean%+', 'std%'],
      # the duration is averaged over folds (* requests statistical analysis, - specifies a lower-the-better metric)
      duration = ['mean*-']
    )

    

Display metrics
===============

Export metrics
==============

Mine metrics
============

Advanced usage
~~~~~~~~~~~~~~

Managing multiple plans
=======================

Composing mathematical operators for the metrics
================================================

Define your own metric operators
================================

Storage within an hdf5 file
===========================

Remote computing
================
